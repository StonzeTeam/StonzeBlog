---
layout: post
title: "SIMD 병렬 프로그래밍"
author: "김지환"
date: 2016-07-09 10:00:00
excerpt: "SIMD 병렬 프로그래밍이 무엇인지 알아봅시다."
tags: [SIMD, Parallel Computing]
comments: true
---

SIMD란 Single Instruction Multiple Data의 약자로, 하나의 명령어로 여러개의 데이터를 한번에 처리하는 기법입니다.
일반적인 프로그램의 경우 대부분 SISD(Single Instruction Single Data)으로 구현되어 있고, 이것은 기본적인 폰노이만 컴퓨터가 사용하는 방식입니다.
하지만 동영상 인코딩, 그래픽 렌더링 등의 작업에 SIMD를 적용하였을 때는 성능적으로 큰 이득을 취할 수 있습니다.

CPU-Z같은 프로그램에서 CPU가 지원하는 명령어 셋들을 확인할 수 있는데, Intel의 경우 MMX(SSE2), AMD는 3D Now!같은 기술들이 SIMD를 의미합니다.


# Scala(SISD) VS SIMD
![](/assets/img/simd_1.jpg)

위의 예는 우리가 일반적으로 사고하는 SISD 방식과 이제부터 알아볼 SIMD 연산에 대한 차이를 나타낸 것입니다.
Vector4 + Vector4를 간단하게 SISD와 SIMD로 표현한다면,

{% highlight Javascript %}

// SISD
var a = [1, 2, 3, 4];
var b = [5, 6, 7, 8];
var c = [];

c[0] = a[0] + b[0];
c[1] = a[1] + b[1];
c[2] = a[2] + b[2];
c[3] = a[3] + b[3];
c; // Array[6, 8, 10, 12]


// SIMD
var a = SIMD.Float32x4(1, 2, 3, 4);
var b = SIMD.Float32x4(5, 6, 7, 8);
var c = SIMD.Float32x4.add(a,b); // Float32x4[6, 8, 10, 12]

{% endhighlight %}

SIMD를 적용하기 좋은 케이스로는 행렬이나 벡터의 연산이 있습니다.
게임을 만들려면 행렬과 벡터의 연산은 필수적인데 SIMD를 이용해 계산하면 한번에 여러개의 데이터를 계산할 수 있게 되어 훨씬 빠른 성능을 기대할 수 있습니다.





# 전통적인 클래스 상속 구조의 문제점

많은 언어에서는 클래스 다중 상속을 지원하지 않습니다. 하지만 인터페이스는 예외로 다중상속을 지원합니다.

인터페이스란, 클래스의 기능 명세와도 같습니다. 그 자체로 인스턴스화 될 수 없고, 껍데기만 있습니다.
그리고 인터페이스를 상속받는 클래스들은 껍데기인 인터페이스의 메서드들을 구현해야만 합니다.

![](/assets/img/160611_interface.png)

날 수 있는 것, 동물은 인터페이스입니다. 이 인터페이스를 상속받는 클래스들이 있고 새는 두 인터페이스를 상속받아서 구현할 수 있습니다.
이런 식의 인터페이스 다중 상속은 가능하지만, 클래스를 다중 상속받아야 할 일이 있다면 어떻게 해야 할까요?

![](/assets/img/160611_mixin.png)

사람인 엄마, 아빠의 유전자를 내가 물려받는 것을 표현한 구조입니다.
여기서 사람은 인터페이스, 엄마, 아빠는 클래스이고 나 또한 클래스입니다.

위에서 보았던 인터페이스를 다중 상속받는 것과 달리 이 그림에선 클래스를 다중 상속받습니다.
대부분의 언어는 다중 상속을 지원하지 않는데 이런 경우 Mixin을 이용하여 가볍게 해결할 수 있습니다!

다음 예제는 아빠의 키와 엄마의 키, 성격을 물려받는데 엄마의 키는 아빠의 키 형질에 의해 무시당하는 것을 표현한 예제입니다.

# Ruby의 Mixin 구현 예시

{% highlight Ruby %}

module Dad
	def tall
		'183cm'
	end
end

module Mom
	def tall
		'160cm'
	end

	def personality
		'kindness'
	end
end

class Me
	include Dad, Mom

	def introduce
		puts tall
		puts personality
	end
end

me = Me.new
me.introduce

# 실행 결과 
# 183cm
# kindness

{% endhighlight %}

언어마다 다를 수 있지만, Ruby같은 경우는 이름이 동일한 메서드의 경우 먼저 include된 모듈(Mixin)을 사용하게 됩니다.


# 비슷하지만 다른 것들
![](/assets/img/traitTerms.png)

Swift에서는 Interface, Trait, Mixin을 이렇게 정의할 수 있다고 합니다.

하지만 일반적으로 Mixin과 Trait는 큰 구분이 없이 혼용해서 사용하는 경우가 많고, 학술적인 정의로 구분하자면 

* Trait : 상태(state)가 없고 메서드만 존재하는 코드 조각(모듈)
* Mixin : Trait와 달리 상태(state)도 가질 수 있음

이렇게 구분할 수 있습니다.


# Component
믹스인 외에도 컴포넌트 패턴을 이용해서 이러한 문제를 해결할 수도 있습니다. 믹스인은 언어에서 지원하는 기능이지만 보통 컴포넌트는 직접 구현해야 합니다. 이 둘의 가장 큰 차이라면, 믹스인과 클래스의 관계는 Is-A 관계입니다. 조금 쉬운 말로 풀어 쓰자면 믹스인은 클래스에 흡수되는 것과 유사합니다. 하지만 컴포넌트는 Has-A 관계입니다. 한마디로 클래스가 컴포넌트들을 가지고 있는 것입니다.

또 다른 차이로, 믹스인으로 구현한 클래스는 변할 수 없지만 컴포넌트로 구현한 클래스는 런타임시에 동적으로 컴포넌트를 추가하거나 삭제할 수 있습니다.

컴포넌트 패턴에 대해서 좀 더 알아보고 싶다면 [이곳](http://gameprogrammingpatterns.com/component.html)을 참고해보세요.

# 정리

상속만을 이용해 OOP를 구현하는 것은 요즘 트렌드에 맞지 않다고 생각합니다. Mixin 또는 Component Pattern을 이용하여 OOP를 구현한다면 더욱 좋은 생산성과 재사용성을 얻을 수 있을거라 생각합니다.


# Reference
* 이미지 출처 - [http://matthijshollemans.com](http://matthijshollemans.com)
* [http://blog.saltfactory.net/ruby/understanding-mixin-using-with-ruby.html](http://blog.saltfactory.net/ruby/understanding-mixin-using-with-ruby.html)
